# 영속성 컨텍스트
**👉 엔티티를 영구 저정하는 환경이라는 뜻**

```JAVA
EntityManager.persist(entity);
```
> 전 시간에서 배운건 `persist`를 사용하면 DB에 저장하는 뜻이라고 했는데, 정확히는 영속성 컨텍스트를 통해 엔티티를 영속한다는 뜻


## 엔티티 생명주기

- 비영속 -> 영속성 컨텍스트랑 전혀 관계가 없음
- 영속 -> 영속성 컨텍스트에 관리되는 상태
- 준영속 -> 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 -> 삭제된 상태


<br><br>

### 비영속
```java
Member member = new Member();
member.setId("member1");
member.setUsername("회원1");
```
> 이렇게 객체만 생성한 상태는 jpa랑 아무런 관련이 없기 때문에 비영속 상태라고 함


<br><br>
### 영속
```java
em.persist(member);
```
> 여기까지 하면 영속 상태가 되는 것임. 
> 정확히는 여기까지 하면 db에 저장되는 것이 아님
> DB에 저장하는 시점은 커밋을 하는 시점에 쿼리가 날라가게 됨!!

<br><br>
### 준영속
```JAVA
em.detach(member);
```
> 이렇게 하면 영속성 컨텍스트에서 분리시킴


<br><br>
### 삭제
```java
em.remove(member);
```



<br><br>

# 영속성 컨텍스트 이점

### 1차 컨텍스트
엔티티를 영속하면 영속성 컨텍스트가 시작되는데 이 때 1차 캐시가 생성됨. 
1차 캐시에 없는 값은 db에서 값을 불러옴. 불러온 값은 1차 캐시에 저장한
다음에 같은 값을 부르면 db에서 쿼리를 날려서 값을 가져오지 않고 1차 캐시에서 가져옴


<br>

### 동일성 보장
자바 컬렉션에서 가져왔을 때 주소가 같은 것 처럼 영속성 동일성을 보장해준다.

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.println(a == b);
```
✏️ why? 1차 캐시가 있기 때문에 

<br>

### 트랜잭션을 지원하는 쓰기 지연 (엔티티 등록할 때)

> 커밋하기 전까지는 db에 저장이 안됨
> 버퍼링 모아서 write


<br>

### 엔티티 수정
> jpa는 자바 컬렉션 사용하는 것처럼 사용하면 돼서
> 수정하고 나서는 persist사용 안해도 됨. 
> 그냥 .set~~ 하고 커밋하면 됨


<br>

### 엔티티 삭제

```java
em.remove(객체);
```







