## **HTTP란?**

HTTP는 (Hypertext transfer Protocol)의 약자이다. 전 세계의 웹브라우저, 서버, 웹 애플리케이션은 모두 HTTP를 통해 서로 대화한다.

## **[ 웹 클라이언트와 서버 ]**

웹 서버는 HTTP 프로토콜로 의사소통하기 때문에 보통 HTTP 서버라고 불린다.

- 클라이언트는 서버에서 HTTP요청을 보내고 서버는 요청된 데이터를 HTTP 응답으로 돌려준다.

> "http://www.oreilly.com/index.html"을 열어보고 싶을 때, 웹브라우저는 www.oreilly.com을 서버로 보내고 서버는 요청받은 객체 (index.html)을 찾고 성공한다면 타입, 길이 등의 정보를 HTTP응답에 실어서 클라이언트에게 보낸다.
> 

## **[ 리소스 ]**

웹 서버는 웹 리소스를 관리하고 제공한다. 가장 단순한 웹 리소스는 웹 서버 시스템의 정적 파일이다.

**➕ 정적 파일 종류**

- 텍스트 파일
- HTML 파일
- 워드 파일
- JPEG이미지 파일
- AVI 동영상 파일

하지만 반드시 정적 파일일 필요는 없다!

도서관의 서가를 탐색하는 웹 게이트웨이, 인터넷 검색엔진도 리소스임

## **[ URI ]**

URI는 Uniform Resource Identifier의 약자이다. 인터넷의 우편물 주소 같은 것으로 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.

👉 URI의 종류에는 URL과 URN이 존재한다.

**🟪 URL**

URL은 Uniform Resource Locator의 약자이다. 리소스 식별자의 가장 흔한 형태이다.

URL은 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려준다.

> http://www.oreilly.com/index.html
> 

> 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따른다.
> 

📝 구체적인 내용은 블로그 다른 글에 적어놓았다.

[HTTP 기초 [URL/Stateless/비연결성]](https://dahliachoi.tistory.com/27?category=995681)


**🟪 URN**

URN은 Uniform Resource Name의 약자이다.

URN은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향을 받지 않는 유일무이한 이름 역할을 한다.

리소스가 그 이름을 변하지 않게 유지하는 한, 여러 종류이 네트워크 접속 프로토콜로 접근해도 문제없다.

하지만 URN은 아직 실험 중인 상태고 널리 채택되지 않았다. 앞으로 URI는 URL과 같은 의미로 생각하면 된다.

## **[ 트랜잭션 ]**

HTTP 트랜잭션은 요청 명령과 응답 결과로 구성되어 있다.

![image](https://user-images.githubusercontent.com/48826098/205247203-dd21bbf5-26d1-4c6a-87f3-fe5b9abbcac2.jpg)

이런 식으로 동작된다.

클라이언트는 메서드를 포함해서 요청을 하고 서버는 상태코드와 메시지를 보낸다.

**🟪 HTTP 메서드**

- GET : 서버에서 클라이언트로 지정한 리소스를 보내라.
- PUT : 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 지정하라.
- DELETE : 지정한 리소스를 서버에서 삭제하라.
- POST : 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라.
- HEAD : 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라.

**🟩 상태코드**

- 200 : 좋다. 문서가 바르게 반환되었다.
- 302 : 다시 보내라. 다른 곳에 가서 리소스를 가져와라.
- 404 : 없음. 리소스를 찾을 수 없다.

HTTP는 상태코드와 함께 사유 구절도 같이 보낸다.

> 위의 사진 처럼 "200 OK" 이런식으로 보냄
> 

➕ 웹브라우저는 시각적으로 풍부한 웹페이지를 가져올 때 대량의 HTTP 트랜잭션을 수행한다.

먼저 페이지 레이아웃을 서술하는 HTML '뼈대'를 한 번의 트랜잭션으로 가져오고나서 이미지, 그래픽 조각 등등 추가          로 HTTP 트랜잭션을 수행한다.

## **[ 메시지 ]**

웹 클라이언트에서 웹 서버로 보낸 HTTP 메시지를 요청 메시지라고 부르고, 서버에서 클라이언트로 가는 메시지는 응답메시지라고 부른다.

HTTP는 보통 시작줄, 헤더, 본문 이렇게 세가지 부분으로 이루어져 있다.

![2](https://user-images.githubusercontent.com/48826098/205247449-a72f9673-15e6-4978-b7ed-2638d5705037.jpg)

**◾ 시작줄**

메시지의 첫 줄은 시작줄로 , 요청이라면 무엇을 해야하는지 응답이라면 무슨 일이 일어났는지 나타낸다.

**◾ 헤더**

시작줄 다음에는 0개 이상의 헤더 필드가 이어진다. 각 헤더필드는 쉬운 구문분석을 위해 쌍점(:)으로 구분되어 있는 하나의 이름과 하나의 값으로 구성된다.

헤어 필드를 추가하려면 그저 한 줄을 더하면 되고 헤더는 꼭 빈 줄로 끝내야한다. (empty line)

**◾ 본문**

빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 올 수 있다.

요청의 본문은 웹 서버로 데이터를 실어 보내며, 응답의 본문은 클라이언트로 데이터를 반환한다. 문자열이며 구조적인 시작줄이나 헤더와 달리, 본문은 임의의 이진 데이터를 포함할 수 있다. 물론 텍스트도 포함할 수 있다.

## **[ TCP 커넥션 ]**

HTTP는 애플리케이션 계층 프로토콜이다. HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서 신경 쓰지 않는다. 대신 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에게 맡긴다.

**➕ HTTP 네트워크 프로토콜 스택**

- 애플리케이션 계층 : HTTP
- 전송 계층 : TCP
- 네트워크 계층 : IP
- 데이터 링크 계층 : 네트워크를 위한 링크 인터페이스
- 물리 계층 : 물리적인 네트워크 하드웨어

HTTP 클라이언트가 서버에 메시지를 전송할 수 있게 되기 전에, 인터넷 프로토콜(IP)주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다.

TCP에서는 서버 컴퓨터에 대한 IP주소와, 그 서버에서 실행 중인 프로그램이 사용 중인 포트번호가 필요하다.

![3](https://user-images.githubusercontent.com/48826098/205247451-a04ee3ca-0635-4dff-8a89-ddd3f257fba0.jpg)

이런 식으로 연결하게 된다.

몇 가지 예를 보면서 살펴보자면

> http://207.200.83.29:80/index.html
> 

**1. http://207.200.83.29:80/index.html**

IP주소 : 207.200.83.29

PORT 번호 : 80을 가지고 있다.

이 경우에는 IP주소와 포트 번호 모두 가지고 있기 때문에 TCP 커넥션이 무리 없이 작동된다.

**2. http://www.netscape.com:80/index.html**

이 경우에는 숫자로 된 IP주소가 존재하지 않는다. 대신 글자로 된 도메인 이름 또는 호스트 명을 가지고 있다.

호스트 명은 도메인 이름 서비스(DNS)를 통해서 쉽게 IP주소로 변화 시킬 수 있다.  또한 포트 번호를 가지고 있기 때문에 TCP 연결을 할 수 있다.

**➕ DNS 설명**

![4](https://user-images.githubusercontent.com/48826098/205247456-9b67480a-4606-4869-a8e2-ac842d4e53ca.jpg)

DNS 서버에서 도메인 이름을 IP주소로 변화시킴

**3. http://www.netscape.com/indexm.html**

이 경우에는 포트 번호가 보이지 않는다. 도메인 명은 DNS로 인해 IP주소로 변경이 가능하지만 포트 번호가 없는 경우에는 기본 값 80으로 가정하면 된다.

## **[ 웹의 구성요소 ]**

### **🟪 프락시**

프락시는 클라이언트와 서버 사이에 위치한 HTTP 중개자 역할을 한다.

즉, 프락시는 클라이언트와 서버 사이에 위치하여 클라이언트의 모든 HTTP 요청을 받아 서버에 전달한다.

**◾ 프락시의 역할**

- 주로 보안을 위해 사용된다. 즉, 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 하는 것이다.
- 요청과 응답을 필터링한다. ( 다운 받을 때 바이러스를 검출하거나 미성년자들이 성인 컨텐츠를 보지 못하게 차단)

### **🟪 캐시**

캐시는 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고 역할을 한다.

따라서, 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 문서를 다운 받을 수 있다.

HTTP는 캐시를 효율적으로 동작하게 하고 캐시된 콘텐츠를 최신 버전으로 유지하면서 동시에 프라이버시도 보호하기 위해 많은 기능을 정의한다. (나중에 더 자세히 공부할 예정)

### **🟪 게이트웨이**

게이트웨이는 다른 애플리케이션과 연결된 특별한 웹 서버이다.

게이트웨이는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사요된다. 언제나 스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룬다. 따라서 클라이언트는 자신이 게이트웨이와 통신하고 있음을 알아채지 못한다.

![5](https://user-images.githubusercontent.com/48826098/205247465-d40fb3bf-0bb1-4078-9e42-f6418da56f68.jpg)

### **🟪 터널**

터널은 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시이다.

HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용된다.

> HTTP 터널을 활용하는 대표적인 예로, 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있다.
> 

### **🟪 에이전트**

에이전트는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램이다.

웹 요청을 만드는 애플리케이션은 뭐든 HTTP 에이전트다.  (나중에 자세히 공부)